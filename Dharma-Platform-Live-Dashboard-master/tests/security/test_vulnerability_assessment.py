"""
Vulnerability assessment and security scanning tests
Tests for common security vulnerabilities and misconfigurations
"""

import pytest
import asyncio
import time
import json
import hashlib
import secrets
from datetime import datetime, timedelta
from typing import Dict, List, Any
import aiohttp
import asyncpg
import motor.motor_asyncio
import redis.asyncio as redis
import subprocess
import socket
import ssl


class VulnerabilityTestConfig:
    """Vulnerability assessment configuration"""
    
    # Service endpoints and ports
    SERVICES = {
        "api_gateway": {"url": "http://localhost:8000", "port": 8000},
        "data_collection": {"url": "http://localhost:8001", "port": 8001},
        "ai_analysis": {"url": "http://localhost:8002", "port": 8002},
        "alert_management": {"url": "http://localhost:8003", "port": 8003},
        "mongodb": {"url": "mongodb://localhost:27017", "port": 27017},
        "postgresql": {"url": "postgresql://localhost:5432", "port": 5432},
        "redis": {"url": "redis://localhost:6379", "port": 6379},
        "elasticsearch": {"url": "http://localhost:9200", "port": 9200}
    }
    
    # Common vulnerability test payloads
    DIRECTORY_TRAVERSAL_PAYLOADS = [
        "../../../etc/passwd",
        "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        "....//....//....//etc/passwd"
    ]
    
    COMMAND_INJECTION_PAYLOADS = [
        "; ls -la",
        "| whoami",
        "&& cat /etc/passwd",
        "`id`",
        "$(whoami)"
    ]


@pytest.fixture
async def vulnerability_clients():
    """Initialize clients for vulnerability testing"""
    clients = {
        'http': aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)),
        'mongodb': motor.motor_asyncio.AsyncIOMotorClient("mongodb://localhost:27017/dharma_test"),
        'postgresql': await asyncpg.connect("postgresql://postgres:password@localhost:5432/dharma_test"),
        'redis': redis.from_url("redis://localhost:6379/0")
    }
    
    yield clients
    
    # Cleanup
    await clients['http'].close()
    clients['mongodb'].close()
    await clients['postgresql'].close()
    await clients['redis'].close()


class TestNetworkSecurity:
    """Test network-level security vulnerabilities"""
    
    async def test_port_scanning_and_service_exposure(self, vulnerability_clients):
        """Test for unnecessary open ports and service exposure"""
        
        port_scan_results = {}
        
        # Test common ports that should NOT be open
        dangerous_ports = [
            22,    # SSH
            23,    # Telnet
            135,   # RPC
            139,   # NetBIOS
        ]
        
        # Test service ports that SHOULD be open
        expected_ports = [
            8000,  # API Gateway
            8001,  # Data Collection
            8002,  # AI Analysis
            8003,  # Alert Management
        ]
        
        def check_port(host, port, timeout=3):
            """Check if a port is open"""
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                result = sock.connect_ex((host, port))
                sock.close()
                return result == 0
            except Exception:
                return False
        
        # Check dangerous ports (should be closed)
        for port in dangerous_ports:
            is_open = check_port("localhost", port)
            port_scan_results[f"dangerous_port_{port}"] = {
                "port": port,
                "is_open": is_open,
                "security_risk": is_open,
                "description": f"Port {port} should be closed for security"
            }
        
        # Check expected service ports (should be open)
        for port in expected_ports:
            is_open = check_port("localhost", port)
            port_scan_results[f"service_port_{port}"] = {
                "port": port,
                "is_open": is_open,
                "service_available": is_open,
                "description": f"Service port {port} availability"
            }
        
        # Check for default database ports (should be secured)
        database_ports = [27017, 5432, 6379, 9200]  # MongoDB, PostgreSQL, Redis, Elasticsearch
        
        for port in database_ports:
            is_open = check_port("localhost", port)
            
            # If open, check if authentication is required
            auth_required = True
            if is_open:
                if port == 27017:  # MongoDB
                    try:
                        # Try to connect without authentication
                        test_client = motor.motor_asyncio.AsyncIOMotorClient(f"mongodb://localhost:{port}")
                        await test_client.admin.command("ismaster")
                        auth_required = False  # Connected without auth
                        test_client.close()
                    except Exception:
                        auth_required = True
                
                elif port == 6379:  # Redis
                    try:
                        test_redis = redis.from_url(f"redis://localhost:{port}")
                        await test_redis.ping()
                        auth_required = False  # Connected without auth
                        await test_redis.close()
                    except Exception:
                        auth_required = True
            
            port_scan_results[f"database_port_{port}"] = {
                "port": port,
                "is_open": is_open,
                "auth_required": auth_required,
                "security_risk": is_open and not auth_required,
                "description": f"Database port {port} security check"
            }
        
        # Calculate security score
        total_checks = len(port_scan_results)
        security_issues = sum(1 for result in port_scan_results.values() 
                            if result.get("security_risk", False))
        
        security_score = ((total_checks - security_issues) / total_checks * 100) if total_checks > 0 else 0
        
        return {
            "port_scan_results": port_scan_results,
            "total_checks": total_checks,
            "security_issues": security_issues,
            "security_score": security_score,
            "network_secure": security_score >= 90
        }
    
    async def test_ssl_tls_configuration(self, vulnerability_clients):
        """Test SSL/TLS configuration and certificate security"""
        
        ssl_results = {}
        
        # Test SSL/TLS configuration for HTTPS endpoints
        https_endpoints = []
        
        # Check if any services are configured with HTTPS
        for service_name, config in VulnerabilityTestConfig.SERVICES.items():
            if config["url"].startswith("https://"):
                https_endpoints.append((service_name, config["url"]))
        
        if not https_endpoints:
            # Test HTTP services for security headers
            for service_name, config in VulnerabilityTestConfig.SERVICES.items():
                if config["url"].startswith("http://") and "port" in config:
                    try:
                        async with vulnerability_clients['http'].get(f"{config['url']}/health") as response:
                            headers = response.headers
                            
                            ssl_results[service_name] = {
                                "https_enabled": False,
                                "security_headers": {
                                    "strict_transport_security": "Strict-Transport-Security" in headers,
                                    "content_security_policy": "Content-Security-Policy" in headers,
                                    "x_frame_options": "X-Frame-Options" in headers,
                                    "x_content_type_options": "X-Content-Type-Options" in headers,
                                    "x_xss_protection": "X-XSS-Protection" in headers
                                }
                            }
                    except Exception as e:
                        ssl_results[service_name] = {"error": str(e)}
        
        else:
            # Test HTTPS configuration
            for service_name, url in https_endpoints:
                try:
                    # Test SSL certificate
                    hostname = url.replace("https://", "").split(":")[0]
                    port = int(url.split(":")[-1]) if ":" in url.replace("https://", "") else 443
                    
                    context = ssl.create_default_context()
                    
                    with socket.create_connection((hostname, port), timeout=10) as sock:
                        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                            cert = ssock.getpeercert()
                            
                            ssl_results[service_name] = {
                                "https_enabled": True,
                                "certificate_valid": True,
                                "certificate_info": {
                                    "subject": dict(x[0] for x in cert.get('subject', [])),
                                    "issuer": dict(x[0] for x in cert.get('issuer', [])),
                                    "version": cert.get('version'),
                                    "not_after": cert.get('notAfter')
                                }
                            }
                
                except Exception as e:
                    ssl_results[service_name] = {
                        "https_enabled": True,
                        "certificate_valid": False,
                        "error": str(e)
                    }
        
        return ssl_results


class TestApplicationSecurity:
    """Test application-level security vulnerabilities"""
    
    async def test_directory_traversal_vulnerabilities(self, vulnerability_clients):
        """Test for directory traversal vulnerabilities"""
        
        # Create test user for authentication
        user_data = {
            "username": "traversal_test_user",
            "email": "traversal@test.com",
            "password": "TraversalTest123!",
            "role": "analyst"
        }
        
        try:
            async with vulnerability_clients['http'].post(
                f"{VulnerabilityTestConfig.SERVICES['api_gateway']['url']}/api/v1/auth/register",
                json=user_data
            ) as response:
                pass
            
            async with vulnerability_clients['http'].post(
                f"{VulnerabilityTestConfig.SERVICES['api_gateway']['url']}/api/v1/auth/login",
                json={"username": user_data["username"], "password": user_data["password"]}
            ) as response:
                if response.status == 200:
                    auth_data = await response.json()
                    token = auth_data['access_token']
                else:
                    token = "test_token"
        except Exception:
            token = "test_token"
        
        headers = {"Authorization": f"Bearer {token}"}
        
        traversal_results = {}
        
        # Test directory traversal in various endpoints
        test_endpoints = [
            "/api/v1/files/",  # File access endpoint
            "/api/v1/reports/",  # Report access endpoint
            "/api/v1/export/",  # Export endpoint
        ]
        
        for endpoint in test_endpoints:
            endpoint_results = {}
            
            for payload in VulnerabilityTestConfig.DIRECTORY_TRAVERSAL_PAYLOADS:
                try:
                    # Test as path parameter
                    async with vulnerability_clients['http'].get(
                        f"{VulnerabilityTestConfig.SERVICES['api_gateway']['url']}{endpoint}{payload}",
                        headers=headers
                    ) as response:
                        status = response.status
                        response_text = await response.text()
                        
                        # Check if traversal was successful (bad) or blocked (good)
                        traversal_blocked = status in [400, 403, 404] or "root:" not in response_text
                        
                        endpoint_results[payload] = {
                            "status": status,
                            "traversal_blocked": traversal_blocked,
                            "response_length": len(response_text)
                        }
                
                except Exception as e:
                    endpoint_results[payload] = {
                        "error": str(e),
                        "traversal_blocked": True  # Exception counts as blocked
                    }
            
            traversal_results[endpoint] = endpoint_results
        
        # Calculate protection effectiveness
        total_attempts = sum(len(results) for results in traversal_results.values())
        blocked_attempts = sum(
            sum(1 for result in results.values() if result.get("traversal_blocked", False))
            for results in traversal_results.values()
        )
        
        protection_rate = (blocked_attempts / total_attempts * 100) if total_attempts > 0 else 0
        
        return {
            "traversal_results": traversal_results,
            "total_attempts": total_attempts,
            "blocked_attempts": blocked_attempts,
            "protection_rate": protection_rate,
            "directory_traversal_protected": protection_rate >= 95
        }
    
    async def test_command_injection_vulnerabilities(self, vulnerability_clients):
        """Test for command injection vulnerabilities"""
        
        # Create test user
        user_data = {
            "username": "injection_test_user",
            "email": "injection@test.com",
            "password": "InjectionTest123!",
            "role": "analyst"
        }
        
        try:
            async with vulnerability_clients['http'].post(
                f"{VulnerabilityTestConfig.SERVICES['api_gateway']['url']}/api/v1/auth/register",
                json=user_data
            ) as response:
                pass
            
            async with vulnerability_clients['http'].post(
                f"{VulnerabilityTestConfig.SERVICES['api_gateway']['url']}/api/v1/auth/login",
                json={"username": user_data["username"], "password": user_data["password"]}
            ) as response:
                if response.status == 200:
                    auth_data = await response.json()
                    token = auth_data['access_token']
                else:
                    token = "test_token"
        except Exception:
            token = "test_token"
        
        headers = {"Authorization": f"Bearer {token}"}
        
        injection_results = {}
        
        # Test command injection in data processing endpoints
        for payload in VulnerabilityTestConfig.COMMAND_INJECTION_PAYLOADS:
            test_data = {
                "platform": "twitter",
                "content": f"Test content {payload}",
                "user_id": f"test_user{payload}",
                "timestamp": datetime.utcnow().isoformat()
            }
            
            try:
                async with vulnerability_clients['http'].post(
                    f"{VulnerabilityTestConfig.SERVICES['data_collection']['url']}/api/v1/ingest",
                    json=test_data,
                    headers=headers
                ) as response:
                    status = response.status
                    response_text = await response.text()
                    
                    # Check if command injection was prevented
                    injection_prevented = status != 500 and "root:" not in response_text and "uid=" not in response_text
                    
                    injection_results[payload] = {
                        "status": status,
                        "injection_prevented": injection_prevented,
                        "response_length": len(response_text)
                    }
            
            except Exception as e:
                injection_results[payload] = {
                    "error": str(e),
                    "injection_prevented": True
                }
        
        # Calculate prevention effectiveness
        total_injections = len(injection_results)
        prevented_injections = sum(1 for result in injection_results.values() 
                                 if result.get("injection_prevented", False))
        
        prevention_rate = (prevented_injections / total_injections * 100) if total_injections > 0 else 0
        
        return {
            "injection_results": injection_results,
            "total_injections": total_injections,
            "prevented_injections": prevented_injections,
            "prevention_rate": prevention_rate,
            "command_injection_protected": prevention_rate >= 95
        }
    
    async def test_information_disclosure_vulnerabilities(self, vulnerability_clients):
        """Test for information disclosure vulnerabilities"""
        
        disclosure_results = {}
        
        # Test for sensitive information in error messages
        error_test_endpoints = [
            "/api/v1/nonexistent",
            "/api/v1/admin/debug",
            "/api/v1/internal/status",
            "/api/v1/.env",
            "/api/v1/config"
        ]
        
        for endpoint in error_test_endpoints:
            try:
                async with vulnerability_clients['http'].get(
                    f"{VulnerabilityTestConfig.SERVICES['api_gateway']['url']}{endpoint}"
                ) as response:
                    response_text = await response.text()
                    
                    # Check for sensitive information in response
                    sensitive_patterns = [
                        "password",
                        "secret",
                        "key",
                        "token",
                        "database",
                        "mongodb://",
                        "postgresql://",
                        "redis://",
                        "traceback",
                        "stack trace"
                    ]
                    
                    sensitive_info_found = any(pattern in response_text.lower() 
                                            for pattern in sensitive_patterns)
                    
                    disclosure_results[endpoint] = {
                        "status": response.status,
                        "sensitive_info_found": sensitive_info_found,
                        "response_length": len(response_text),
                        "information_secure": not sensitive_info_found
                    }
            
            except Exception as e:
                disclosure_results[endpoint] = {
                    "error": str(e),
                    "information_secure": True
                }
        
        # Test for debug information in headers
        try:
            async with vulnerability_clients['http'].get(
                f"{VulnerabilityTestConfig.SERVICES['api_gateway']['url']}/health"
            ) as response:
                headers = response.headers
                
                debug_headers = [
                    "X-Debug",
                    "X-Powered-By",
                    "Server",
                    "X-AspNet-Version",
                    "X-Framework"
                ]
                
                debug_info_found = any(header in headers for header in debug_headers)
                
                disclosure_results["debug_headers"] = {
                    "debug_headers_found": debug_info_found,
                    "headers_secure": not debug_info_found,
                    "found_headers": [h for h in debug_headers if h in headers]
                }
        
        except Exception as e:
            disclosure_results["debug_headers"] = {"error": str(e)}
        
        # Calculate information security score
        total_tests = len(disclosure_results)
        secure_tests = sum(1 for result in disclosure_results.values() 
                          if result.get("information_secure", False))
        
        security_score = (secure_tests / total_tests * 100) if total_tests > 0 else 0
        
        return {
            "disclosure_results": disclosure_results,
            "total_tests": total_tests,
            "secure_tests": secure_tests,
            "security_score": security_score,
            "information_disclosure_protected": security_score >= 90
        }


class TestDatabaseSecurity:
    """Test database security configurations"""
    
    async def test_database_access_controls(self, vulnerability_clients):
        """Test database access controls and authentication"""
        
        db_security_results = {}
        
        # Test MongoDB security
        try:
            # Test if MongoDB requires authentication
            unauthorized_client = motor.motor_asyncio.AsyncIOMotorClient("mongodb://localhost:27017")
            
            try:
                # Try to access without authentication
                await unauthorized_client.admin.command("listDatabases")
                mongodb_auth_required = False
            except Exception:
                mongodb_auth_required = True
            
            unauthorized_client.close()
            
            db_security_results["mongodb"] = {
                "auth_required": mongodb_auth_required,
                "security_configured": mongodb_auth_required
            }
        
        except Exception as e:
            db_security_results["mongodb"] = {"error": str(e)}
        
        # Test Redis security
        try:
            # Test if Redis requires authentication
            unauthorized_redis = redis.from_url("redis://localhost:6379")
            
            try:
                await unauthorized_redis.ping()
                redis_auth_required = False
            except Exception:
                redis_auth_required = True
            
            await unauthorized_redis.close()
            
            db_security_results["redis"] = {
                "auth_required": redis_auth_required,
                "security_configured": redis_auth_required
            }
        
        except Exception as e:
            db_security_results["redis"] = {"error": str(e)}
        
        # Test PostgreSQL security
        try:
            # Test if PostgreSQL allows unauthorized connections
            try:
                unauthorized_pg = await asyncpg.connect("postgresql://localhost:5432/dharma_test")
                await unauthorized_pg.close()
                pg_auth_required = False
            except Exception:
                pg_auth_required = True
            
            db_security_results["postgresql"] = {
                "auth_required": pg_auth_required,
                "security_configured": pg_auth_required
            }
        
        except Exception as e:
            db_security_results["postgresql"] = {"error": str(e)}
        
        # Calculate overall database security
        total_databases = len(db_security_results)
        secure_databases = sum(1 for result in db_security_results.values() 
                             if result.get("security_configured", False))
        
        db_security_score = (secure_databases / total_databases * 100) if total_databases > 0 else 0
        
        return {
            "database_security_results": db_security_results,
            "total_databases": total_databases,
            "secure_databases": secure_databases,
            "security_score": db_security_score,
            "databases_secure": db_security_score >= 80
        }


@pytest.mark.asyncio
async def test_vulnerability_assessment_suite():
    """Run complete vulnerability assessment test suite"""
    
    print("Starting vulnerability assessment...")
    
    # Run vulnerability tests
    pytest_args = [
        __file__,
        "-v",
        "--tb=short",
        "--asyncio-mode=auto"
    ]
    
    return pytest.main(pytest_args)


if __name__ == "__main__":
    asyncio.run(test_vulnerability_assessment_suite())